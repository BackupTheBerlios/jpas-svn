package org.jpas.da;

import java.sql.*;
import org.apache.log4j.*;

/**
 * <p>Title: JPAS</p>
 * <p>Description: Java based Personal Accounting System</p>
 * <p>Copyright: Copyright (c) 2004</p>
 * <p>License: Distributed under the terms of the GPL v2</p>
 * @author Justin Smith
 * @version 1.0
 */

public class InitDB
{
	private static final Logger defaultLogger = Logger.getLogger(InitDB.class);
	public static final InitDB instance = new InitDB();

	private InitDB()
	{
	}

	private void deleteTable(final String tableName)
	{
		final String sqlDeleteStr = "DROP TABLE " + tableName + " IF EXISTS";
		try
		{
			ConnectionManager.getInstance().update(sqlDeleteStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlDeleteStr, sqle);
			throw new RuntimeException(sqlDeleteStr, sqle);
		}
	}

	private void deleteSequence(final String sequenceName)
	{
		final String sqlDeleteStr = "DROP SEQUENCE " + sequenceName;
		try
		{
			ConnectionManager.getInstance().update(sqlDeleteStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlDeleteStr, sqle);
			throw new RuntimeException(sqlDeleteStr, sqle);
		}
	}

	public void createUser(final String userName, final String passwd, final boolean admin)
	{
		final String sqlCreate = "CREATE USER " + userName + " PASSWORD " + passwd + (admin ? "ADMIN" : "");
		try
		{
			ConnectionManager.getInstance().update(sqlCreate);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlCreate, sqle);
			throw new RuntimeException(sqlCreate, sqle);
		}
	}

	public void deleteUser(final String userName)
	{
		final String sqlDrop = "DROP USER " + userName;
		try
		{
			ConnectionManager.getInstance().update(sqlDrop);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlDrop, sqle);
			throw new RuntimeException(sqlDrop, sqle);
		}
	}

	public void changePassword(final String userName, final String passwd)
	{
		final String sqlAlter = "ALTER USER " + userName + " SET PASSWORD " + passwd;
		try
		{
			ConnectionManager.getInstance().update(sqlAlter);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlAlter, sqle);
			throw new RuntimeException(sqlAlter, sqle);
		}

	}

	public void deleteAccountTable()
	{
		deleteTable(DBNames.TN_ACCOUNT);
		deleteSequence(DBNames.SEQ_ACCOUNT_ID);
	}

	public void createAccountTable()
	{
		final String sqlCreateStr = "CREATE TABLE " + DBNames.TN_ACCOUNT
										  + " ( " + DBNames.CN_ACCOUNT_ID
										  + " INTEGER PRIMARY KEY, "
										  + DBNames.CN_ACCOUNT_NAME
										  + " VARCHAR(64), UNIQUE("
										  + DBNames.CN_ACCOUNT_NAME + ") )";

		final String sqlSequenceStr = "CREATE SEQUENCE "
										  + DBNames.SEQ_ACCOUNT_ID
										  +" AS INTEGER";

		try
		{
		  ConnectionManager.getInstance().update(sqlCreateStr);
		}
		catch(final SQLException sqle)
		{
		  defaultLogger.error(sqlCreateStr, sqle);
		  throw new RuntimeException(sqlCreateStr, sqle);
		}

		try
		{
			ConnectionManager.getInstance().update(sqlSequenceStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlSequenceStr, sqle);
			throw new RuntimeException(sqlSequenceStr, sqle);
		}
	}

	public void deleteTransactionTable()
	{
		deleteTable(DBNames.TN_TRANSACTION);
		deleteSequence(DBNames.SEQ_TRANSACTION_ID);
	}

	public void createTransactionTable()
	{
		final String sqlCreateStr = "CREATE TABLE "
			+ DBNames.TN_TRANSACTION + " ("
			+ DBNames.CN_TRANSACTION_ID
			  + " INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
			+ DBNames.CN_TRANSACTION_PAYEE + " VARCHAR(64), "
			+ DBNames.CN_TRANSACTION_ACCOUNT + " INTEGER, "
			+ DBNames.CN_TRANSACTION_AMOUNT + " BIGINT, "
			+ DBNames.CN_TRANSACTION_DATE + " CHAR(8), "
			+ DBNames.CN_TRANSACTION_NUM + " VARCHAR(8), "
			+ DBNames.CN_TRANSACTION_MEMO + " VARCHAR(64), "
			+ DBNames.CN_TRANSACTION_OPPOSITE + " INTEGER, "
			+ " FOREIGN KEY (" + DBNames.CN_TRANSACTION_ACCOUNT
			  + ") REFERENCES " + DBNames.TN_ACCOUNT + "(id), "
			+ " FOREIGN KEY (" + DBNames.CN_TRANSACTION_OPPOSITE
			  + ") REFERENCES " + DBNames.TN_TRANSACTION + "(id) "
			+ ")";

		final String sqlIndexAccount = "CREATE INDEX " + DBNames.IDX_TRANSACTION_ACCOUNT + " ON " + DBNames.TN_TRANSACTION
				+ "(" + DBNames.CN_TRANSACTION_ACCOUNT + ", "
				+ DBNames.CN_TRANSACTION_DATE + ")";

		final String sqlIndexTransaction = "CREATE INDEX " + DBNames.IDX_TRANSACTION_PAYEE + " ON " + DBNames.TN_TRANSACTION
				+ "(" + DBNames.CN_TRANSACTION_ACCOUNT + ", "
				+ DBNames.CN_TRANSACTION_PAYEE + ")";

		final String sqlSequenceStr = "CREATE SEQUENCE "
									 + DBNames.SEQ_TRANSACTION_ID
									 +" AS INTEGER";

		try
		{
			ConnectionManager.getInstance().update(sqlCreateStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlCreateStr, sqle);
			throw new RuntimeException(sqlCreateStr, sqle);
		}

		try
		{
			ConnectionManager.getInstance().update(sqlIndexAccount);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlIndexAccount, sqle);
			throw new RuntimeException(sqlIndexAccount, sqle);
		}

		try
		{
			ConnectionManager.getInstance().update(sqlIndexTransaction);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlIndexTransaction, sqle);
			throw new RuntimeException(sqlIndexTransaction, sqle);
		}

		try
		{
			ConnectionManager.getInstance().update(sqlSequenceStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlSequenceStr, sqle);
			throw new RuntimeException(sqlSequenceStr, sqle);
		}

	}

	public void deleteCategoryTable()
	{
		deleteTable(DBNames.TN_CATEGORY);
		deleteSequence(DBNames.SEQ_CATEGORY_ID);
	}

	public void createCategoryTable()
	{
		final String sqlCreateStr = "CREATE TABLE " + DBNames.TN_CATEGORY + " ( "
			+ DBNames.CN_CATEGORY_ID + " INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
			+ DBNames.CN_CATEGORY_NAME + " VARCHAR(64), "
			+ DBNames.CN_CATEGORY_PARENT + " INTEGER, "
			+ DBNames.CN_CATEGORY_TAX_DEDUCTABLE + " BOOLEAN, "
			+ " FOREIGN KEY ("+ DBNames.CN_CATEGORY_PARENT +") REFERENCES "
			+ DBNames.TN_CATEGORY + "("+ DBNames.CN_CATEGORY_ID +")"
			+ ")";
		final String sqlIndexStr = "CREATE INDEX "+ DBNames.IDX_CATEGORY_NAME +" ON "
									+ DBNames.TN_CATEGORY + " ("+ DBNames.CN_CATEGORY_NAME +")";
		final String sqlSequenceStr = "CREATE SEQUENCE "
									+ DBNames.SEQ_CATEGORY_ID
									+ " AS INTEGER";

		try
		{
			ConnectionManager.getInstance().update(sqlCreateStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlCreateStr, sqle);
			throw new RuntimeException(sqlCreateStr, sqle);
		}

		try
		{
			ConnectionManager.getInstance().update(sqlIndexStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlIndexStr, sqle);
			throw new RuntimeException(sqlIndexStr, sqle);
		}

		try
		{
			ConnectionManager.getInstance().update(sqlSequenceStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlSequenceStr, sqle);
			throw new RuntimeException(sqlSequenceStr, sqle);
		}
	}

	public void deleteReminderTable()
	{
		deleteTable(DBNames.TN_REMINDER);
		deleteSequence(DBNames.SEQ_REMINDER_ID);
	}

	public void createReminderTable()
	{
		final String sqlCreateStr = "CREATE TABLE " + DBNames.TN_REMINDER
			+ "  ( "
			+ DBNames.CN_REMINDER_ID + " INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
			+ DBNames.CN_REMINDER_PAYEE + " VARCHAR(64), "
			+ DBNames.CN_REMINDER_ACCOUNT + " INTEGER, "
			+ DBNames.CN_REMINDER_AMOUNT_METHOD + " INTEGER, "
			+ DBNames.CN_REMINDER_AMOUNT_VALUE + " INTEGER, "
			+ DBNames.CN_REMINDER_REPEAT_METHOD + " INTEGER, "
			+ DBNames.CN_REMINDER_REPEAT_VALUE + " INTEGER, "
			+ DBNames.CN_REMINDER_CATEGORY + " INTEGER, "
			+ DBNames.CN_REMINDER_MEMO + " VARCHAR(64), "
			+ " FOREIGN KEY (" + DBNames.CN_REMINDER_ACCOUNT + ") REFERENCES "
			+ DBNames.TN_ACCOUNT + "("+ DBNames.CN_ACCOUNT_ID +"), "
			+ " FOREIGN KEY ("+ DBNames.CN_REMINDER_CATEGORY +") REFERENCES "
			+ DBNames.TN_CATEGORY + "("+ DBNames.CN_CATEGORY_ID +") "
			+ ")";

		final String sqlSequenceStr = "CREATE SEQUENCE "
										  + DBNames.SEQ_REMINDER_ID
										  +" AS INTEGER";

		try
		{
			ConnectionManager.getInstance().update(sqlCreateStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlCreateStr, sqle);
			throw new RuntimeException(sqlCreateStr, sqle);
		}

		try
		{
			ConnectionManager.getInstance().update(sqlSequenceStr);
		}
		catch(final SQLException sqle)
		{
			defaultLogger.error(sqlSequenceStr, sqle);
			throw new RuntimeException(sqlSequenceStr, sqle);
		}
	}


	public static void main(final String[] args)
	{
		BasicConfigurator.configure();

		instance.deleteReminderTable();
		instance.deleteTransactionTable();
		instance.deleteAccountTable();
		instance.deleteCategoryTable();

		instance.createCategoryTable();
		instance.createAccountTable();
		instance.createTransactionTable();
		instance.createReminderTable();
	}
}
